{"id": "1005301", "question": "有一个1000万行的dataframe", "description": "<div class=\"col-md-11 col-xs-10\"><p>df只有一列a</p><p>从第一行开始a的每10行相加放到a的后边形成suma </p><p>第一个suma =sum（df.a[0:9]）</p><p>第2个suma =sum（df.a[1:10]）</p><p><br/></p><p>用最笨的方法计算 大概3个小时 </p><p>有没有高效的方法呢</p></div>", "viewer": 2481, "tags": ["统计/机器学习", "Python"], "answers": [{"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>pandas里有rolling，可以求移动和以及移动均值的。</p><pre><code class=\"python\">df['a'].rolling(window=10).sum()</code></pre></div>", "lvl2_answer": []}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>你可以插入一个辅助列叫flag，第0-9行flag=0，10-19行flag=1，20-29行flag=2.</p><pre><code class=\"python\">df['flag'] = np.arange(len(df)) // 10</code></pre><p>然后以flag为key对a列进行groupby求和就可以了</p><pre><code class=\"python\">df.groupby('flag', as_index=False).agg({'a': 'sum'})</code></pre></div>", "lvl2_answer": ["suma.at[0,s] =sum（df.a[0:9]）\nsuma.at[1,s] =sum（df.a[1:10]）\n求和是有交叉的"]}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>可以换用numpy操作，应该能快一些</p></div>", "lvl2_answer": []}]}