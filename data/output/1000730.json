{"id": "1000730", "question": "[0, 1]内随机抽取n个不重叠闭区间的概率", "description": "<div class=\"col-md-11 col-xs-10\"><p>在闭区间[0, 1]内，我们随机取出两点（服从均匀分布）A和B，形成一个新的闭区间[min{A,B}, max{A,B}]。如此反复n次，我们就有了n个随机闭区间。那么这n个闭区间不出现重叠的概率是多大呢？</p></div>", "viewer": 4903, "tags": ["数学", "概率论", "趣味数学"], "answers": [{"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>答案是</p><p>$$\\frac{2^n n!}{(2n)!}.$$</p><p><br/></p><p>思路大致如下：</p><p>我们是随机按照均匀分布抽取$n$个闭区间的上下界。我们把$n$个区间的下界从小到大排序，也就是$(x_{1,1},x_{1,2}),(x_{2,1},x_{2,2}),\\cdots,(x_{n,1},x_{n,2})$，满足$x_{1,1}&lt;x_{2,1}&lt;x_{3,1}&lt;\\cdots &lt; x_{n,1}$。<x_ p=\"\" x_=\"\"></x_></p><p>在这种情况下，唯一能够达到所有闭区间不重叠的情况是</p><p>$$x_{1,1} &lt; x_{1,2} &lt; x_{2,1} &lt; x_{2,2} &lt; x_{3,1} &lt; x_{3,2} &lt; \\cdots &lt; x_{n,1} &lt; x_{n,2}.$$<x_ p=\"\"></x_></p><p>因为我们只在乎其排序，而且均匀随机抽样。这个问题就等价于从集合$\\{1,2,3,\\cdots,2n\\}$中无放回的抽样。<br/></p><p>符合不重叠的唯一可能性是</p><p>$$x_{1,1}=1,x_{1,2}=2,x_{2,1}=3,\\cdots,x_{n,1}=2n-1,x_{n,2}=2n,$$</p><p>而所有的可能性一共有</p><p>$$\\frac{(2n)!}{2^n n!}.$$</p><p>然后就可以得到概率。</p><p><br/></p></div>", "lvl2_answer": ["所有的可能性一共有，这个公式的每一项有人帮忙解释下吗？"]}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>我用python验证了下高代兄的答案</p><pre><code class=\"python\">import math\r\nimport pandas as pd\r\nimport numpy as np\r\n\r\nn = 3\r\nrounds = 10000\r\np = 0\r\nfor m in range(rounds):\r\n    bounds = pd.DataFrame(columns=['lower_bound', 'upper_bound'])\r\n    for i in range(n):\r\n        bounds.loc[i] = np.sort(np.random.uniform(0, 1, 2))\r\n    bounds.sort_values('lower_bound', inplace=True)\r\n    diff = np.diff(bounds['upper_bound'].values)\r\n    p += np.all(diff &lt;= 0) / float(rounds)\r\nprint('simulation', p)\r\nprint('true:', ((2 ** n) * math.factorial(n)) / math.factorial(2*n))</code></pre><p>得到的结果：</p><pre><code class=\"python\">simulation： 0.0675\r\ntrue: 0.06666666666666667</code></pre></div>", "lvl2_answer": []}]}