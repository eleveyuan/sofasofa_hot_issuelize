{"id": "1000331", "question": "为啥Xgboost比GradientBoost好那么多？", "description": "<div class=\"col-md-11 col-xs-10\"><p>我之前是用的GradientBoost模型，做了特征工程，又选了参数，roc auc才达到0.75的水平。我现在换成最近超级火的XGBoost，什么都没做，roc auc直接飙到了0.82！为什么它比GradientBoost好那么多？</p></div>", "viewer": 14617, "tags": ["统计/机器学习", "监督式学习", "开放问题"], "answers": [{"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>（1）增加了正则项，树越复杂，惩罚越大，这防止了over-fitting，而GradientBoosting并没有惩罚项。</p><p>（2）在迭代更新的时候，Xgboost采用了二阶导数（海瑟矩阵），而GradientBoosting只是用了一阶导数（梯度）。</p><p>此外，xgboost跑起来也更快，因为采用了并行计算、块处理、稀疏矩阵处理技术等等。</p></div>", "lvl2_answer": ["海瑟矩阵是什么？", "请问二阶导数近似loss function相比梯度下降会加快运行速度吗？还是会提高精度？", "精度是根据收敛条件决定的，但是收敛速度会更快，因为是二阶收敛速度。"]}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p><span style=\"font-size: 14px;\">xgboost是从决策树一步步发展而来的。</span></p><p><span style=\"font-weight: bold; font-size: 14px;\">决策树</span><span style=\"font-size: 14px;\"> $\\longrightarrow$ 对样本重抽样，然后多个树平均 $\\longrightarrow$</span><span style=\"font-weight: bold; font-size: 14px;\"> Tree bagging</span></p><p><span style=\"font-weight: bold; font-size: 14px;\">Tree bagging</span><span style=\"font-size: 14px;\"> $\\longrightarrow$ 再同时对特征进行随机挑选 $\\longrightarrow$ </span><span style=\"font-weight: bold; font-size: 14px;\">随机森林</span></p><p><span style=\"font-weight: bold; font-size: 14px;\">随机森林</span><span style=\"font-size: 14px;\"> $\\longrightarrow$ 对随机森林中的树进行加权平均，而非简单平均$\\longrightarrow$ </span><span style=\"font-weight: bold; font-size: 14px;\">Boosing (Adaboost, GradientBoost)</span></p><p><span style=\"font-weight: bold; font-size: 14px;\">boosting</span><span style=\"font-size: 14px;\"> $\\longrightarrow$ 对boosting中的树进行正则化 $\\longrightarrow$ </span><span style=\"font-weight: bold; font-size: 14px;\">xgboosting</span></p><p><span style=\"font-size: 14px;\">从这条线一路发展，就能看出为什么xgboost的优势了。</span></p></div>", "lvl2_answer": ["非常赞", "emmm   个人感觉上述不是很准确或者完备，Adaboost 还有对样本的权重处理，GBDT 则不会修改分类器权重，XGBoost 也不只是假如正则，最大优势应该是在于引入二阶梯度"]}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><ul><li><span style=\"font-size: 14px;\">传统GBDT以CART作为基分类器，xgboost还支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）。传统GBDT在优化时只用到一阶导数信息，xgboost则对代价函数进行了二阶泰勒展开，同时用到了一阶和二阶导数。顺便提一下，xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。</span><br/></li><li><span style=\"font-size: 14px;\">xgboost在代价函数里加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、每个叶子节点上输出的score的L2模的平方和。从Bias-variance tradeoff角度来讲，正则项降低了模型的variance，使学习出来的模型更加简单，防止过拟合，这也是xgboost优于传统GBDT的一个特性。</span></li><li><span style=\"font-size: 14px;\">Shrinkage（缩减），相当于学习速率（xgboost中的eta）。xgboost在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间。实际应用中，一般把eta设置得小一点，然后迭代次数设置得大一点。（补充：传统GBDT的实现也有学习速率）</span></li><li><span style=\"font-size: 14px;\">列抽样（column subsampling）。xgboost借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算，这也是xgboost异于传统gbdt的一个特性。对缺失值的处理。对于特征的值有缺失的样本，xgboost可以自动学习出它的分裂方向。</span></li><li><span style=\"font-size: 14px;\">xgboost工具支持并行。boosting不是一种串行的结构吗?怎么并行的？注意xgboost的并行不是tree粒度的并行，xgboost也是一次迭代完才能进行下一次迭代的（第t次迭代的代价函数里包含了前面t-1次迭代的预测值）。xgboost的并行是在特征粒度上的。我们知道，决策树的学习最耗时的一个步骤就是对特征的值进行排序（因为要确定最佳分割点），xgboost在训练之前，预先对数据进行了排序，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。这个block结构也使得并行成为了可能，在进行节点的分裂时，需要计算每个特征的增益，最终选增益最大的那个特征去做分裂，那么各个特征的增益计算就可以开多线程进行。</span></li><li><span style=\"font-size: 14px;\">可并行的近似直方图算法。树节点在进行分裂时，我们需要计算每个特征的每个分割点对应的增益，即用贪心法枚举所有可能的分割点。当数据无法一次载入内存或者在分布式情况下，贪心算法效率就会变得很低，所以xgboost还提出了一种可并行的近似直方图算法，用于高效地生成候选的分割点。</span></li></ul></div>", "lvl2_answer": []}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>因为xgboost针对regression tree采用了dropout regularization。（详情见<a href=\"https://arxiv.org/abs/1505.01866\" target=\"_blank\">该论文</a>）</p></div>", "lvl2_answer": []}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>1.损失函数是用泰勒展式二项逼近，也就是海森矩阵，而不是像gbdt里的就是一阶导数</p><p>\n</p><p>2.对树的结构进行了正则化约束(regularization)，防止模型过度复杂，降低了过拟合的可能性</p><p>\n</p><p>3.节点分裂的方式不同，gbdt是用的gini系数，xgboost是经过优化推导后的</p><p>4.优化了计算过程，缩短了运行时间</p></div>", "lvl2_answer": []}, {"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>推荐这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/58269560\" target=\"_blank\">从决策树到XGBoost</a></p></div>", "lvl2_answer": []}]}