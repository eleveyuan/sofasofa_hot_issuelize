{"id": "1007442", "question": "请问我的训练值输出和预测值输出为什么一直不变", "description": "<div class=\"col-md-11 col-xs-10\"><p>import numpy as np\n</p><p>import pandas as pd\n</p><p>import  tensorflow as tf\n</p><p>from sklearn import metrics\n</p><p>from sklearn.metrics import accuracy_score, roc_auc_score, precision_score\n</p><p>from keras.utils import to_categorical\n</p><p>fileName1='data1.csv'\n</p><p>fileName2='data2.csv'\n</p><p>batchSize=1\n</p><p>ratio = 0.8\n</p><p>def readFile(fileName):\n</p><p>    data = pd.read_csv(fileName)\n</p><p>    allData = np.array(data.loc[:2000, :])\n</p><p>\n</p><p>    xData=np.array(allData)\n</p><p>    return  xData\n</p><p>\n</p><p># 打乱数据并生成batch数据集\n</p><p>def batch_data(data):\n</p><p>    # 打乱顺序\n</p><p>    data_size = data.shape[0]   # 数据集个数\n</p><p>    arr = np.arange(data_size)  # 生成0到data_size个数\n</p><p>    np.random.shuffle(arr)      # 随机打乱arr数组\n</p><p>    data = data[arr]            # 将data以arr索引重新组合\n</p><p>    # label = label[arr]\n</p><p>    # 将label以arr索引重新组合\n</p><p>    num = np.int(data.shape[0] * ratio)\n</p><p>    return data\n</p><p>def Transpose(stringArray):\n</p><p>    list=[]\n</p><p>    for i in range(stringArray.shape[0]):\n</p><p>        list.append(np.empty(shape=(2*len(stringArray[0][0]))))\n</p><p>    for t in range(stringArray.shape[0]):\n</p><p>     index = 0\n</p><p>     for i in range(len(stringArray[t][0])):\n</p><p>         list[t][index]=ord(stringArray[t][0][i])\n</p><p>         index=index+1\n</p><p>     for j in range(len(stringArray[t][1])):\n</p><p>        list[t][index] = ord(stringArray[t][1][j])\n</p><p>        index=index+1\n</p><p>    strarray=np.array(list)\n</p><p>    return strarray\n</p><p>\n</p><p>def one_hotEncoder(totaldata,len):\n</p><p> list1 = []\n</p><p> for i in range(totaldata.shape[0]):\n</p><p>        list1.append(np.zeros(shape=(60,91)))\n</p><p> for t in range(totaldata.shape[0]):\n</p><p>    data = totaldata[t][0]+totaldata[t][1]\n</p><p>    alphabet = 'abcdefghijklmnopqrstuvwxyz0123456789.,/?:;|]}[{=+-_)(*&amp;^%$#@!`~ZXCVBNM&lt;&gt;ASDFGHJKLPOIUYTREWQ'\n</p><p>    char_to_int = dict((c, i) for i, c in enumerate(alphabet))\n</p><p>    integer_encoded = [char_to_int[char] for char in data]\n</p><p>    onehot_encoded = list()\n</p><p>    for value in integer_encoded:\n</p><p>        letter = [0 for _ in range(len(alphabet))]\n</p><p>        letter[value] = 1\n</p><p>        onehot_encoded.append(letter)\n</p><p>    # print('np.array(onehot_encoded).shape')#行数就是字符数\n</p><p>    list1.append(np.array(onehot_encoded))\n</p><p> onehot_array=np.array(list1)\n</p><p>\n</p><p> return onehot_array\n</p><p>def dataSplit(transarray,stringarray):\n</p><p>    num = np.int(stringarray.shape[0] * ratio)\n</p><p>    x_train = transarray[:num,:,]\n</p><p>    y_train = stringarray[:num,2:]\n</p><p>    x_test = transarray[num:,:,]\n</p><p>    y_test = stringarray[num:,2:]\n</p><p>    return  x_train,x_test,y_train,y_test\n</p><p>\n</p><p>def active(n):\n</p><p>    if n&gt;0.5:\n</p><p>        return 1\n</p><p>    else:\n</p><p>        return 0\n</p><p>\n</p><p>roundT =1\n</p><p>learnRateT = 0.001\n</p><p>unitCount = 128\n</p><p>rowCount = 660\n</p><p>element_size = 28\n</p><p>time_steps = 28\n</p><p>num_classes =2\n</p><p>batch_size = 200\n</p><p>hidden_layer_size = 128\n</p><p>def builNetWork():\n</p><p>    # time_steps =cellCounts\n</p><p>    x = tf.placeholder(shape=[1,60,91], dtype=tf.float32)\n</p><p>    yTrain = tf.placeholder(shape=[1],dtype=tf.float32)\n</p><p>    rnn_cell = tf.contrib.rnn.GRUCell(hidden_layer_size)#hiden_layer_size就是最终输出的output的列数\n</p><p>    outputs, finalState = tf.nn.dynamic_rnn(cell=rnn_cell,inputs=x,dtype=tf.float32,time_major=False)#output的size为(batchsize,hiddenlayersize)\n</p><p>    outputs=tf.nn.dropout(outputs,0.01)\n</p><p>    w2 = tf.Variable(tf.constant(0.1,shape=[hidden_layer_size,1]), dtype=tf.float32)\n</p><p>    b2 = tf.Variable(tf.constant(0.1,shape=[1]), dtype=tf.float32)\n</p><p>    y = tf.sigmoid(tf.reduce_sum(tf.matmul(outputs[-1], w2) )+ b2)\n</p><p>    loss = tf.square(y - yTrain)\n</p><p>    train = tf.train.AdagradOptimizer(learnRateT).minimize(loss)\n</p><p>    return x, y,  train, time_steps, yTrain,loss,outputs, finalState\n</p><p>\n</p><p>\n</p><p>\n</p><p>#读取数据\n</p><p>data1=readFile(fileName1)\n</p><p>data2=readFile(fileName2)\n</p><p>#拼接数据\n</p><p>totaldata=np.vstack((data1,data2))\n</p><p># #打乱数据\n</p><p>randomdata=batch_data(totaldata)\n</p><p>transarray=one_hotEncoder(randomdata,len)\n</p><p># #数字化\n</p><p># transarray=Transpose(randomdata)\n</p><p>#切分数据\n</p><p>x_train,x_test,y_train,y_test=dataSplit(transarray,randomdata)\n</p><p>#定义网络\n</p><p>x, y,  train, time_steps,  yTrain,loss,outputs, finalState=builNetWork()\n</p><p>#运行会话\n</p><p>sess = tf.Session()\n</p><p>sess.run(tf.global_variables_initializer())\n</p><p>for i in range(roundT):\n</p><p>    total_loss = 0.0\n</p><p>    for j in range(y_train.shape[0]):\n</p><p>        x_trains = np.reshape(x_train[j], (1, 60, 91))\n</p><p>        result = sess.run([loss,y],\n</p><p>                          feed_dict={x: x_trains, yTrain: y_train[j]})\n</p><p>\n</p><p>        if j % 20 == 1:\n</p><p>            print(\"i: %d, loss: %s,y:%s,ytrain:%d\\n\"\n</p><p>                  % (i, result[0],result[1],y_train[j]))\n</p><p>\n</p><p>#测试数据\n</p><p>result = np.empty(shape=(y_test.shape[0],1), dtype=np.int)\n</p><p>for i in range(y_test.shape[0]):\n</p><p>\n</p><p>    x_trains = np.reshape(x_test[i], (1, 60,91))\n</p><p>    # print(x_trains)\n</p><p>    results = sess.run([y], feed_dict={x:x_trains})\n</p><p>    print(results)\n</p><p>    result[i][0] = results[0]\n</p><p>\n</p><p>y1=[]\n</p><p>for i in range(result.shape[0]):\n</p><p>    y1.append(result[i][0])\n</p><p>y2=[]\n</p><p>for i in range(y_test.shape[0]):\n</p><p>    y2.append(y_test[i][0])\n</p><p>y_pred=np.array(y1)\n</p><p>y_true=np.array(y2)\n</p><p>print(\"accurcy\")\n</p><p>print(accuracy_score(y_true, y_pred))\n</p><p>print(\"F1\")\n</p><p>print(metrics.f1_score(y_true, y_pred, average='weighted'))\n</p><p>print(\"ROC\")\n</p><p>print(roc_auc_score(y_true, y_pred))\n</p><p>print(\"召回率rec\")\n</p><p>print(metrics.recall_score(y_true, y_pred, average='macro'))\n</p><p>print(\"pre准确率\")\n</p><p>print(precision_score(y_true, y_pred, average='weighted'))</p></div>", "viewer": 1345, "tags": ["统计/机器学习", "时间序列", "TensorFlow"], "answers": [{"lvl1_answer": "<div class=\"col-md-11 col-xs-10 p-r\"><p>试着调一下学习率吧</p></div>", "lvl2_answer": ["调了也不行"]}]}